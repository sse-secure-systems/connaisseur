# configure connaisseur deployment
deployment:
  replicasCount: 3
  image: securesystemsengineering/connaisseur:v2.0.0
  helmHookImage: securesystemsengineering/connaisseur:helm-hook-v1.0
  imagePullPolicy: Always
  resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi
  nodeSelector: {}
  tolerations: []
  affinity: {}

# configure connaisseur service
service:
  type: ClusterIP
  port: 443

### VALIDATORS ###
# validators are a set of configurations (hosts, types, public keys) that can be
# used for validating one or multiple images (or image signatures). They are tied
# to their respective image(s) via the image policy below. There are a few handy
# validators pre-configured.
validators:
- name: allow     # always allow image
  type: static
  approve: true
- name: deny      # always deny image
  type: static
  approve: false
- name: default   # the default validator which is always used, if no validator is specified in image policy
  type: notaryv1  # cosign is also experimetally supported
  host: notary.docker.io
  pub_keys:
  - name: default   # the default key which is always used, if no key is specified in image policy
    key: |          # enter your key here
      -----BEGIN PUBLIC KEY-----
      <add your public key here>
      -----END PUBLIC KEY-----
  # cert: |  # for communication, using a selfsigned certificate
  #   -----BEGIN CERTIFICATE-----
  #   ...
  #   -----END CERTIFICATE-----
  # auth:  # basic authentication against the notary server
  #   # either
  #   username: notaryuser
  #   password: notarypass
  #   # or
  #   secret_name: notarysecret  # define a k8s secret with `username` and `password` fields
- name: dockerhub_essentials   # pre-configured validator for public notary from dockerhub
  type: notaryv1
  host: notary.docker.io
  pub_keys:
  - name: docker_official   # public key for official docker images (e.g. redis)
    key: |
      -----BEGIN PUBLIC KEY-----
      MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOXYta5TgdCwXTCnLU09W5T4M4r9f
      QQrqJuADP6U7g5r9ICgPSmZuRHP/1AYUfOQW3baveKsT969EfELKj1lfCA==
      -----END PUBLIC KEY-----
  - name: sse_official      # public key for connaisseur images
    key: |
      -----BEGIN PUBLIC KEY-----
      MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEsx28WV7BsQfnHF1kZmpdCTTLJaWe
      d0CA+JOi8H4REuBaWSZ5zPDe468WuOJ6f71E7WFg3CVEVYHuoZt2UYbN/Q==
      -----END PUBLIC KEY-----
- name: cosign_essentials   # pre-configured validator for public cosign signatures
  type: cosign
  pub_keys:
  - name: sse_official      # public key for connaisseur images (currently only testimages)
    key: |
      -----BEGIN PUBLIC KEY-----
      MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEvtc/qpHtx7iUUj+rRHR99a8mnGni
      qiGkmUb9YpWWTS4YwlvwdmMDiGzcsHiDOYz6f88u2hCRF5GUCvyiZAKrsA==
      -----END PUBLIC KEY-----

### IMAGE POLICY ###
# the image policy ties validators and images together whereby always only the most
# specific rule (pattern) is applied. Specify if and how images should be validated
# by which validator.
policy:
- pattern: "*:*"
- pattern: "docker.io/library/*:*"
  validator: dockerhub_essentials
  with:
    key: docker_official
- pattern: "k8s.gcr.io/*:*"
  validator: allow
- pattern: "docker.io/securesystemsengineering/connaisseur:*"
  validator: dockerhub_essentials
  with:
    key: sse_official
- pattern: "docker.io/securesystemsengineering/connaisseur:helm-hook-*"
  validator: allow
- pattern: "docker.io/securesystemsengineering/testimage:*"
  validator: dockerhub_essentials
  with:
    key: sse_official
- pattern: "docker.io/securesystemsengineering/testimage:co-*"
  validator: cosign_essentials
  with:
    key: sse_official



# in detection mode, deployment will not be denied, but only prompted
# and logged. This allows testing the functionality without
# interrupting operation.
detection_mode: false

# A list of namespaces that will be subject to Connaisseur verification.
# If the list contains '*' - all namespaces will be monitored.
targetNamespaces: ['*']

# debug: true

# alerting is implemented in form of simple POST requests with json payload
# you can use and/or adapt the predefined Slack/OpsGenie/Keybase templates and the examples below
# to channel alert notifications to Slack/OpsGenie/Keybase or create a custom template for a customized alert
# payload to use with a simple POST request to the receiver_url to receive alerts.
# Parameters you can use in your templates are "alert_message", "priority", "connaisseur_pod_id", "cluster",
# "timestamp", "request_id" and "images" each one basically meaning what their names indicate
#
# Below is an example config

#alerting:
#  cluster_identifier: example-cluster-staging-europe # defaults to "not specified"
#  admit_request:
#    templates:
#      # <template> needs to be chosen such that <template>.json matches one of the file names
#      # in the ./alert_payload_templates directory
#      - template: opsgenie #REQUIRED!
#        receiver_url: https://api.eu.opsgenie.com/v2/alerts #REQUIRED!
#        priority: 4 #(defaults to 3)
#        custom_headers: ["Authorization: GenieKey <Your-Genie-Key>"]
#        payload_fields:
#          responders:
#            - username: "testuser@testcompany.de"
#              type: user
#          visibleTo:
#            - username: "testuser@testcompany.de"
#              type: user
#          tags:
#            - "deployed_an_image"
#        fail_if_alert_sending_fails: True  # (defaults to False, turning it to True will make Connaisseur deny your
#                                           # deployment (even in detection mode))
#      - template: slack #REQUIRED!
#        receiver_url: https://hooks.slack.com/services/<Your-Slack-Hook-Path>
#        priority: 1
#  reject_request:
#    templates:
#      - template: keybase  #REQUIRED!
#        receiver_url: https://bots.keybase.io/webhookbot/<Your-Keybase-Hook-Token>
#        fail_if_alert_sending_fails: True
